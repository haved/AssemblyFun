<html>
    <head>
        <title>Hassembly Specification</title>
        <link rel="stylesheet" type="text/css" href="HassemblySpec.css">
    </head>
    <body>
        <div class="content">
            <h1>Hassembly Fun specification</h1>
            The Hassembly instruction set and syntax is heavily based on arm assembly. <br>
            <h2>Stuff you can write:</h2>
            <h4>Comments</h4>;Everything behind a semi-colon is a comment!<br>
            <h4>Labels</h4>
            All lines with a colon are labels. Example: <br>
                <i>myLabel:</i><br>
            Labels are a reference to the address of the line coming after it. Either an instruction or a word. <br>
            <h4>Nicknames</h4>
            You can use <i>.req</i> to assign a nickname to a register. You use <i>.unreq</i> to remove the nickname. Example: <br>
                <span class="asm">r0 .req pinNum<br>
                    MOV pinNum, #0x200000<br>
                    .unreq pinNum</span>
<!--Registers-->
            <div class="note register">
                <b>Registers</b><br>
                The are 16 32-bit registers. r0 to r15. r0 to r12 are general use registers. Special registers:<br>
                r13: Stack pointer (sp)<br>
                r14: Link register (lr)<br>
                r15: Program counter (pc)<br>
            </div>
            <br>
<!--Immediate values-->
            <div class="note immediateVal">
                <b>Immediate values</b><br>
                Immediate values are written in one of three ways:<br>
                Decimal: <span class="asm">#1230</span><br>
                Hexadecimal: <span class="asm">#0xFF00</span><br>
                Binary: <span class="asm">#0b1101</span><br>
                Example:<br>
                <span class="asm">
                    MOV r0, #2550<br>
                    MOV r1, #0xFF<br>
                    MOV r2, #0b10010011<br>
                </span>
                More often than not thou can't express negative immediate values. In the few cases you can, the syntax is: <span class="asm">#-4095</span><br>
                NB: Please note that not all immediate values fit in all instructions. #imm8 means the immediate value is 8 bit and can't exceed 255. The rules are especially weird for <span class="FSO">Flexible Second Operands</span>
            </div>
            <br>
<!--Shifting-->
            <div class="note shift">
                <b>Shifting</b><br>
                In Hassembly there are four methods of shifting:<br>
                <span class="asm">LSL</span>: Logical shift left<br>
                <span class="asm">LSR</span>: Logical shift right<br>
                <span class="asm">ASR</span>: Arithmetic shift right<br>
                <span class="asm">ROR</span>: Rotate right<br>
                Shifting is always done by either a 5 bit immediate value, or the least significant byte of a register.<br>
                Shifting operations can be used as
                <span class="instructionDef">instructions</span> and in <span class="FSO">Flexible Second Operands</span>.
                <div class="defaultNote innerNote">
                    <b>Logical vs Arithmetic shift right</b><br>
                    The difference between Logical shift right (<span class="asm">LSR</span>) and Arithmetic shift right (<span class="asm">ASR</span>) is that <span class="asm">LSR</span>
                                        always fills the vacated bit positions (beige) with 0, while <span class="asm">ASR</span> uses the integer's old sign (orange).<br>
                    This effectively means <span class="asm">LSR</span> doesn't handle negative (signed) numbers as one might expect.<br>
                    This also means <span class="asm">ASR</span> doesn't handle unsigned numbers as one might expect.<br>
                    Because all positive signed integers have the sign 0 (See: <a href="https://en.wikipedia.org/wiki/Two%27s_complement">Two's compliment</a>),
                    there is no difference between <span class="asm">LSR</span> and <span class="asm">ASR</span> when shifting positive signed numbers.<br>
                    A common way of thinking about shifting is that you multiply by 2^shiftLeft or divide by 2^shiftRight.
                        This is true with <span class="asm">LSR</span> for unsigned numbers, with <span class="asm">ASR</span> for signed numbers.<br>
                    <div class="examples innerNote">
                        Examples:<br>
                        <span class="immediateVal">
                            <span class="orangeMarker">0</span>010 1110 0001 1111</span> >> 4 = <br>
                        Both Logical shift right and Arithmetic shift right gives:<br>
                        <span class="immediateVal"><span class="beigeMarker">0000</span> <span class="orangeMarker">0</span>010 1110 0001</span><br>
                        <br>
                        <span class="immediateVal">
                            <span class="orangeMarker">1</span>001 1011 0101 1100</span> >> 4 = <br>
                        Logical shift right gives:<br>
                        <span class="immediateVal"><span class="beigeMarker">0000</span> <span class="orangeMarker">1</span>001 1011 0101</span><br>
                        Arithmetic shift right gives:<br>
                        <span class="immediateVal"><span class="beigeMarker">1111</span> <span class="orangeMarker">1</span>001 1011 0101</span><br>
                    </div>
                    Learn more about <span class="asm">LSL, LSR, ASR</span> and <span class="asm">ROR</span> <a href="http://www.davespace.co.uk/arm/introduction-to-arm/barrel-shifter.html">here!</a>
                </div>
            </div>
            <br>
<!--Flexible second operands-->
            <div class="note FSO">
                <b>Flexible Second Operand</b>
                <i>Aliases: FSO, Operand2</i><br>
                The FSO is flexible and can take one of four forms: <br>
                <span class="immediateVal">Immediate value</span>: <span class="instructionDef">#imm</span> - An 8-bit number rotated right by an even number of places (4 bits*2)<br>
                <span class="register">Register</span>: <span class="instructionDef">Rm</span>
                        - The value of a register<br>
                <span class="register">Register</span> shifted by <span class="immediateVal">immediate value
                    </span>: <span class="instructionDef">Rm, shift #imm5</span> - The value of Rm <span class="shift">shifted</span> by a 5 bit number<br>
                <span class="register">Register</span> shifted by
                        <span class="register">register</span>:
                        <span class="instructionDef">Rm, shift Rs</span>
                        - The value of Rm <span class="shift">shifted</span>
                        by the last significant byte of Rs<br>
                <div class="examples innerNote">
                    Examples using <span class="asm">MOV Rd,Operand2</span>:<br>
                    <span class="asm">
                        MOV r0, #5<br>
                        MOV r0, r1<br>
                        MOV r0, #0x2A<br>
                        MOV r0, #0xFF000<br>
                        MOV r0, r1, LSL #5<br>
                        MOV r0, r1, LSR r2<br>
                    </span>
                </div>
            </div>
<!--Mnemonic documentation-->
            <div class="note defaultNote">
                <b>Mnemonic documentation syntax</b><br>
                <i>&ltoperation&gt</i> is the operation.<br>
                <span class="asm">{cond}</span> is the <u>optional</u>
                <span class="condition">condition</span> for the instruction.<br>
                <span class="asm">Rd</span> is the destination <span class="register">register</span>.<br>
                <span class="asm">Rn</span> is the first input <span class="register">register</span>.<br>
                <span class="asm">Rm</span> is the second input <span class="register">register</span>.<br>
                <span class="asm">Rs</span> is the shift <span class="register">register</span>.<br>
                <span class="asm">Ra</span> is the accumulate <span class="register">register</span>.<br>
                <span class="asm">#imm8</span> is an 8 bit <span class="immediateVal">immediate value</span>.<br>
                <i>Operand2</i> is a <span class="FSO">Flexible second operand</span>.
            </div>
            <br>
<!--Mnemonics-->
            <h2>Mnemonics</h2>
<!--Moving instructions-->
            <div class="instructionDef">Moving instructions:     &ltoperation&gt{cond} Rd,Operand2</div>
            MOV - Move; Rd=Operand2;<br>
            MVN - Move NOT; Rd=0xFFFFFFFF EOR Operand2;<br>
            <div class="examples">Examples:<br>
                <span class="asm">
                    MOV r0, #0xFF00<br>
                    MVN r0, r1<br>
                    MOV r3, #255<br>
                    MOV r0, r1, LSL #5
                </span>
            </div>
            <br>
<!--Arithmetic instructions-->
            <div class="instructionDef">Arithmetic instructions:     &ltoperation&gt{cond} Rd,Rn,Operand2</div>
            ADD - Addition; Rd=Rn+Operand2<br>
            SUB - Subtraction; Rd=Rn-Operand2<br>
            RSB - Reverse subtraction; Rd=Operand2-Rn<br>
            <div class="examples">Examples:<br>
                <span class="asm">
                    ADD r0, r1, r2; r0=r1+r2;<br>
                    ADD r0, r0, #10; r0+=10;<br>
                    SUB r0, r1, r2, LSL #6; r0 = r1-(r2<<6);<br>
                    RSB r2, r2, r1, LSR #2; r2 = (r1>>2)-r2;<br>
                </span>
            </div>
            <br>
<!--Logical instructions-->
            <div class="instructionDef">Logical instructions:     &ltoperation&gt{cond} Rd,Rn,Operand2</div>
            AND - Bitwise logical and; Rd=Rn&Operand2<br>
            ORR - Bitwise inclusive or; Rd=Rn|Operand2<br>
            EOR - Bitwise exclusive or; Rd=Rn^Operand2<br>
            BIC - Bitwise clear; Rd=Rn AND NOT Operand2<br>
            <div class="examples">Examples:<br>
                <span class="asm">
                    AND r0, r0, #0xFF - r0&=0xFF; //Only the last byte is kept<br>
                    ORR r1, r0, #0b1010 - r1=r0|10; //The bits 1010 will always be true after this<br>
                    ORR r1, r2, r3, LSL r4 - r1=r2|(r3&lt&lt r4);<br>
                    EOR r0, r1, 0xFF - r0=r1^255; //Invert the last byte of r1 and store it in r0<br>
                    EOR r0, r1, r2, ror #4 - r0=r1^(r2&gt&gt 4);<br>
                </span>
            </div>
            <br>
<!--Compare instructions-->
            <div class="instructionDef">Compare instructions:     &ltoperation&gt{cond} Rn,Operand2</div>
            All these instructions set the compare flags. Z - Zero, N - Negative, S - Signed bit. These are used by the
            <span class="condition">conditional</span> codes.<br>
            A compare value of 0, for instance, means equal.<br>
            CMP - Compare two values. Sets the compare flags to Rn-Operand2<br>
            CMN - Compare negative. Sets the compare flags to Rn+Operand2<br>
            TST - bitwise test. Sets the compare flags to Rn&Operand2<br>
            TEQ - bitwise equivalence. Sets the compare flags to Rn^Operand2<br>
            <div class="examples">Examples:<br>
                <span class="asm">
                    CMP r0, #50 - Sets the comparison flags to r0-50<br>
                    CMN r1, r2 - Sets the comparison flags to r1+r2<br>
                    TST r1, #0b0100 - Sets the comparison flags to r1 AND 0b0100<br>
                </span>
            </div>
            <br>
<!--Shifting instructions-->
            <div class="instructionDef">Shifting instructions:     &ltoperation&gt{cond} Rd,Rn,Rs</div>
            <div class="instructionDef">Shifting instructions:     &ltoperation&gt{cond} Rd,Rn,#imm5</div>
            Choose the one that fits:    byte shift = Rs&0xFF;    byte shift = #imm5;<br>
            LSL - Logical shift left. Rd=Rn&lt&ltshift<br>
            LSR - Logical shift right. Rd=Rn>>shift<br>
            ASR - Arithmetic shift right. Rd=Rn>>shift<br>
            ROR - Rotate right. Rd=(Rn>>shift) | (Rn&lt&lt(32-shift))<br>
            See <span class="shift">Shifting</span> for more information.<br>
            <div class="examples">Examples:<br>
                <span class="asm">
                    LSL r0, r0, #4 - r0&lt&lt=4;<br>
                    LSR r1, r2, r3 - r1=r2>>(r3&0xFF);<br>
                    ASR r2, r3, #12 - r2=r3>>12;<br>
                    ROR r1, r1, #12 - r1=(r1>>12)|(r1&lt&lt18);<br>
                </span>
            </div>

<!--Conditional codes-->
            <div class="note condition">
                <b>Condition codes</b><br>
                Condition codes are used to restrict which instructions are done.
                The code replaces <span class="instructionDef">{cond}</span> when writing the instruction.
                Without any instruction code, the instruction is always run.<br>
                The compare flags are: Z - Zero (value==0), N - Negative (value < 0), S - Signed bit (value & 0x8000000); Z implies NOT(S) AND NOT(N)
                <i>The conditional codes look at ZNS, the compare flags set in the Compare instructions</i>
                <div class="innerNote defaultNote">
                    <b>All Condition codes</b><br>
                    EQ - Equal (Z)
                    NE - Not equal (!Z)
                    GT - Signed greater than (!N^S & NOT(Z))
                    LT - Signed less than (N^S)
                    GE - Signed greater or equal (!N^S)
                    LE - Signed less or equal (N^S|Z)
                    HI - Unsigned higher (!(N|Z))
                    LS - Unsigned lower or same (N|Z)
                </div>
            </div>
        </div>
    </body>
</html>